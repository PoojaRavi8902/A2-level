<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Chapter 20 — Further Programming (Python)</title>
  <style>
    body { font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; background:#f4f6f8; color:#102a43; margin:0; padding:24px; }
    .container{ max-width:980px; margin:0 auto; }
    header{ background:#fff; padding:18px 20px; border-radius:10px; box-shadow:0 4px 12px rgba(15,23,42,0.06); }
    h1{ margin:0; font-size:1.6rem; }
    p.lead{ margin:6px 0 0; color:#334e68; }
    details{ background:#fff; margin-top:14px; padding:14px 18px; border-radius:10px; box-shadow:0 2px 8px rgba(2,6,23,0.06); }
    summary{ font-weight:700; font-size:1.05rem; cursor:pointer; }
    pre{ background:#0b1020; color:#e6eef8; padding:12px; border-radius:8px; overflow:auto; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', monospace; font-size:0.9rem; }
    code{ color:#e7f6ff; }
    h3{ margin:8px 0; color:#0b3d91; }
    ul{ line-height:1.6; }
    .tasks{ background:#f0f7ff; border-left:4px solid #2b6cb0; padding:10px; border-radius:6px; margin-top:8px; }
    .small{ font-size:0.95rem; color:#334e68; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Chapter 20 — Further Programming (Python)</h1>
      <p class="lead small">Advanced programming concepts, object-oriented design, recursion, file handling, modular programming, and professional testing & debugging. Extensive examples and many practice tasks after each section.</p>
    </header>

    <details open>
      <summary>Advanced Programming Concepts — Core Principles</summary>
      <div>
        <h3>Overview</h3>
        <p class="small">Advanced programming blends algorithmic thinking with software engineering practices: abstraction, encapsulation, separation of concerns, immutability vs mutability, concurrency basics, and performance-aware coding. We concentrate on patterns and Python idioms that make code robust and maintainable.</p>

        <h3>Key ideas (expanded)</h3>
        <ul class="small">
          <li><strong>Immutability vs Mutability:</strong> prefer immutable data for predictable functions; understand when lists/dicts are mutated and how that affects callers.</li>
          <li><strong>Pure Functions:</strong> functions that have no side effects and return the same output for same inputs—easier to test.</li>
          <li><strong>Design Patterns (brief):</strong> Factory, Singleton (use sparingly), Strategy (pass functions or classes), Adapter (wrap incompatible interface), Iterator (Python iterators/generators).</li>
          <li><strong>Generators & Iterators:</strong> lazily produce values for memory efficiency with <code>yield</code>.</li>
          <li><strong>Context Managers:</strong> for resource handling (<code>with</code> statement) and making code exception-safe.</li>
        </ul>

        <h3>Python idioms & examples</h3>
        <pre><code class="language-python"># generator example: produce fibonacci numbers lazily
def fib_gen(limit):
    a, b = 0, 1
    while a &lt; limit:
        yield a
        a, b = b, a + b

for n in fib_gen(100):
    print(n)

# context manager: ensure resource cleanup
with open('data.txt') as f:
    for line in f:
        process(line)
</code></pre>

        <div class="tasks">
          <strong>Practice tasks — Advanced Concepts (10+)</strong>
          <ol class="small">
            <li>Explain why immutable keys (tuples) are used in dictionaries but lists are not allowed. Provide code to demonstrate mutability pitfalls.</li>
            <li>Write a pure function that normalises a list of numbers (scale between 0 and 1). Show how unit tests would look.</li>
            <li>Implement a simple Iterator class for prime numbers and test first 20 primes.</li>
            <li>Compare a list comprehension vs generator expression memory usage for a large dataset (write sample code and comment on results).</li>
            <li>Create a context manager using <code>@contextlib.contextmanager</code> that times a code block and prints elapsed time.</li>
            <li>Describe a situation where a generator improves performance and write an example handling very large logs.</li>
            <li>Write code to demonstrate Python's default argument trap (mutable default) and provide the correct pattern.</li>
            <li>Explain tail-call optimisation—does Python support it? Provide an alternative technique for deep recursion in Python.</li>
            <li>Profile a small function using <code>timeit</code> and show improvement by using local variables vs global lookups.</li>
            <li>Implement Strategy pattern by passing different comparator functions to a generic sort-by-key routine.</li>
          </ol>
        </div>
      </div>
    </details>

    <details>
      <summary>Object-Oriented Programming (OOP) in Python</summary>
      <div>
        <h3>Core Concepts — expanded</h3>
        <ul class="small">
          <li><strong>Class and Instance:</strong> classes define structure; instances hold state.</li>
          <li><strong>Encapsulation:</strong> hide internal state—use naming convention <code>_</code> or <code>__</code> for private attributes.</li>
          <li><strong>Inheritance:</strong> reuse/extend behaviour. Prefer composition over inheritance when appropriate.</li>
          <li><strong>Polymorphism:</strong> same interface, different implementations.</li>
          <li><strong>Special Methods:</strong> <code>__init__</code>, <code>__repr__</code>, <code>__eq__</code>, <code>__len__</code>, etc. Implement these for idiomatic classes.</li>
          <li><strong>Data Classes:</strong> use <code>@dataclass</code> for concise record-like classes (Python 3.7+).</li>
        </ul>

        <h3>Design advice</h3>
        <p class="small">Keep classes small and focused (Single Responsibility Principle). Provide clear public methods and minimize direct attribute manipulation from outside. Document invariants and expected state transitions.</p>

        <h3>Code examples (detailed)</h3>
        <pre><code class="language-python">from dataclasses import dataclass, field
from typing import List

@dataclass
class Student:
    id: int
    name: str
    marks: List[int] = field(default_factory=list)

    def average(self) -> float:
        if not self.marks:
            return 0.0
        return sum(self.marks) / len(self.marks)

    def add_mark(self, m: int):
        if not 0 &lt;= m &lt;= 100:
            raise ValueError('mark out of range')
        self.marks.append(m)

    def __repr__(self):
        return f"Student({self.id}, {self.name}, avg={self.average():.2f})"

# inheritance example
class Person:
    def __init__(self, name):
        self.name = name

class Teacher(Person):
    def teach(self, topic):
        print(f"{self.name} teaches {topic}")
</code></pre>

        <div class="tasks">
          <strong>OOP Practice tasks — Many (12+)</strong>
          <ol class="small">
            <li>Design a class hierarchy for geometric shapes (Shape -> Rectangle, Circle). Implement area() and perimeter(). Show polymorphism by iterating over a mixed list of shapes.</li>
            <li>Refactor a procedural student report program into OOP: identify classes, attributes and methods.</li>
            <li>Write unit tests for <code>Student.add_mark</code> including invalid input cases.</li>
            <li>Implement <code>__eq__</code> and <code>__lt__</code> for Student so students can be sorted by average.</li>
            <li>Demonstrate composition by building a <code>Course</code> class that contains Students and computes course average.</li>
            <li>Create a mutable & an immutable Person class; demonstrate what happens when you try to change attributes.</li>
            <li>Implement a factory function that creates different Logger objects (ConsoleLogger, FileLogger) based on a config value.</li>
            <li>Use <code>@property</code> to create a read-only attribute <code>gpa</code> computed from marks.</li>
            <li>Show how to use mixins to provide serialization (to_dict) functionality to any data class.</li>
            <li>Explain and demonstrate the diamond problem in multiple inheritance and how Python’s MRO resolves it.</li>
            <li>Implement a context manager as a class (with <code>__enter__</code> and <code>__exit__</code>) that temporarily changes working directory.</li>
            <li>Design classes to represent a simple banking system — account creation, deposit, withdrawal, transfer — with tests that ensure invariants (balance >= 0).</li>
          </ol>
        </div>
      </div>
    </details>

    <details>
      <summary>Recursion and Reusable Code</summary>
      <div>
        <h3>Recursion — deep dive</h3>
        <p class="small">Recursion solves problems by calling the same function on a smaller subproblem. Always define base case(s) and prove termination. Be mindful of Python's recursion limit (default ~1000) and prefer iterative solutions or explicit stacks for deep recursions.</p>

        <h3>Examples & analysis</h3>
        <pre><code class="language-python"># classic factorial
def factorial(n):
    if n &lt;= 1:
        return 1
    return n * factorial(n-1)

# Fibonacci (naive recursive) — exponential time
def fib(n):
    if n &lt;= 1:
        return n
    return fib(n-1) + fib(n-2)

# better: memoization
from functools import lru_cache

@lru_cache(maxsize=None)
def fib_memo(n):
    if n &lt;= 1:
        return n
    return fib_memo(n-1) + fib_memo(n-2)
</code></pre>

        <h3>Reusable code techniques</h3>
        <ul class="small">
          <li>Write small, well-documented functions with clear inputs/outputs.</li>
          <li>Use modules and packages to group related functionality.</li>
          <li>Provide clear APIs and keep helper functions private (prefix with <code>_</code>).</li>
          <li>Document with docstrings and include examples in doctest format.</li>
          <li>Use decorators for cross-cutting concerns (logging, caching, validation).</li>
        </ul>

        <div class="tasks">
          <strong>Recursion & Reuse Practice tasks — Many (12+)</strong>
          <ol class="small">
            <li>Write recursive and iterative versions of factorial and compare performance for n up to 900 (be mindful of recursion limit).</li>
            <li>Implement quickselect (k-th smallest) recursively and explain average vs worst-case complexity.</li>
            <li>Use <code>@lru_cache</code> to speed up a naive recursive dynamic programming solution (e.g., coin change). Show before/after timings.</li>
            <li>Refactor a piece of repetitive code into a reusable function and write tests to ensure behaviour preserved.</li>
            <li>Implement a decorator that logs function entry/exit and another that caches results; apply both using stacking order considerations.</li>
            <li>Write a recursion that traverses nested dictionaries/lists and collects all integer values into one flat list.</li>
            <li>Demonstrate tail recursion concept and show why Python won’t optimise it; provide a conversion to an iterative approach using a stack.</li>
            <li>Package a small utility module (e.g., text processing helpers) and demonstrate importing it from a different script.</li>
            <li>Create doctests for 5 reusable functions and show how to run them from command line.</li>
            <li>Implement a generic memoize decorator from scratch and compare to <code>lru_cache</code>.</li>
            <li>Explain how to write idempotent functions and implement one for safely creating directories.</li>
            <li>Write a recursive solution to generate all permutations of a list and ensure tests cover duplicates handling.</li>
          </ol>
        </div>
      </div>
    </details>

    <details>
      <summary>File Handling and Error Management</summary>
      <div>
        <h3>File operations — best practices</h3>
        <p class="small">Always open files using <code>with</code> to ensure closure. Consider text vs binary modes and character encodings (UTF-8). For large files prefer streaming and buffered processing.</p>

        <pre><code class="language-python"># reading line-by-line
with open('bigfile.txt', 'r', encoding='utf-8') as f:
    for line in f:
        process(line.strip())

# writing safely
with open('out.csv', 'w', encoding='utf-8') as f:
    f.write('col1,col2\n')
</code></pre>

        <h3>Error handling & exceptions</h3>
        <p class="small">Use try/except to handle expected errors. Avoid bare except: which hides bugs. Use specific exception types and consider cleanup in <code>finally</code> or context managers.</p>

        <pre><code class="language-python">try:
    with open('config.json') as f:
        cfg = json.load(f)
except FileNotFoundError:
    raise SystemExit('Missing configuration file')
except json.JSONDecodeError as e:
    print('Bad JSON:', e)
else:
    start(cfg)
finally:
    logger.info('Attempted to load config')
</code></pre>

        <h3>Validation and defensive programming</h3>
        <ul class="small">
          <li>Check preconditions early and raise informative exceptions.</li>
          <li>Use <code>assert</code> for developer-time checks (not for user input validation in production).</li>
          <li>Log meaningful messages — include variable context.</li>
        </ul>

        <div class="tasks">
          <strong>File & Error Practice tasks — Many (12+)</strong>
          <ol class="small">
            <li>Write a script that reads a CSV robustly: skip malformed lines, report line numbers of errors, and summarize errors at end.</li>
            <li>Implement a backup mechanism: when writing output, write to <code>file.tmp</code> and then atomically rename to final filename.</li>
            <li>Design a function that safely parses integers from input with retries; write tests for invalid inputs.</li>
            <li>Demonstrate exception chaining using <code>raise From</code> to preserve original traceback.</li>
            <li>Implement logging with rotating file handler for a long-running script and show log formatting best practices.</li>
            <li>Write code that reads JSON and validates required keys; provide user-friendly error messages when missing keys.</li>
            <li>Show use of contextlib.ExitStack for managing multiple context managers whose count is dynamic.</li>
            <li>Create a CLI that accepts filename arguments and handles missing files gracefully, returning proper exit codes.</li>
            <li>Write unit tests mocking file I/O using <code>unittest.mock</code> to simulate read/write errors.</li>
            <li>Implement file locking for concurrent writes (explain platform limitations and use <code>portalocker</code> or <code>fcntl</code> where applicable).</li>
            <li>Write an importer that skips BOM bytes and handles different newline conventions robustly.</li>
            <li>Design a recoverable import process: partial processing, checkpointing, and resume after failure.</li>
          </ol>
        </div>
      </div>
    </details>

    <details>
      <summary>Modular Programming</summary>
      <div>
        <h3>Principles</h3>
        <p class="small">Modularity improves readability and testability. Group related functions into modules; expose only the public API. Use packages for larger projects and follow PEP8 and project layout conventions.</p>

        <h3>Packaging & imports</h3>
        <pre><code class="language-python"># project structure
# myapp/
#   __init__.py
#   utils.py
#   db.py
#   cli.py

# in cli.py
from .utils import parse_args
from .db import connect

def main():
    args = parse_args()
    conn = connect(args.dsn)
</code></pre>

        <h3>Versioning and API stability</h3>
        <p class="small">Document public interfaces and avoid breaking changes. Semantic versioning helps consumers decide when to upgrade.</p>

        <div class="tasks">
          <strong>Modular Programming Practice tasks — Many (10+)</strong>
          <ol class="small">
            <li>Refactor a long script into a package with clear module boundaries. Show __init__.py to expose only the public API.</li>
            <li>Write a module with well-documented functions and publish it locally using <code>pip install -e .</code> for development installs.</li>
            <li>Demonstrate relative vs absolute imports and when to use each.</li>
            <li>Create a small package and write setup.cfg/pyproject.toml with metadata and dependencies.</li>
            <li>Show how to structure tests directory and run tests with pytest discovering tests automatically.</li>
            <li>Implement a plugin architecture using entry points (explain conceptually; provide simple stub).</li>
            <li>Describe how to write backward-compatible changes to a module API and provide an example using wrapper functions.</li>
            <li>Write a module-level __all__ and explain its effect on wildcard imports.</li>
            <li>Explain and implement dependency injection for easier testing of modules that use external services.</li>
            <li>Document a public module using Sphinx or simple docstrings and show how to generate HTML docs locally.</li>
          </ol>
        </div>
      </div>
    </details>

    <details>
      <summary>Testing and Debug Techniques</summary>
      <div>
        <h3>Testing strategy</h3>
        <p class="small">Good testing covers unit tests, integration tests, and acceptance tests. Use pytest/unittest, mock external dependencies, and adopt continuous testing in CI pipelines.</p>

        <h3>Unit testing examples</h3>
        <pre><code class="language-python"># pytest style example
# test_utils.py
from myapp.utils import normalize

def test_normalize():
    assert normalize([0, 50, 100]) == [0.0, 0.5, 1.0]

# mocking example
from unittest.mock import patch

def test_read_file(monkeypatch):
    monkeypatch.setattr('builtins.open', lambda f, mode='r': io.StringIO('a,b,c'))
    assert read_csv('dummy') == [['a','b','c']]
</code></pre>

        <h3>Debugging techniques</h3>
        <ul class="small">
          <li>Use logging instead of prints for real projects; log levels help filter verbosity.</li>
          <li>Use pdb or rich.traceback for interactive debugging and better tracebacks.</li>
          <li>Reproduce bugs with minimal test case and add regression test.</li>
          <li>Binary search the failing commit (git bisect) when regressions appear after changes.</li>
        </ul>

        <div class="tasks">
          <strong>Testing & Debugging Practice tasks — Many (12+)</strong>
          <ol class="small">
            <li>Write unit tests for 15 functions covering normal, boundary, and invalid inputs. Aim for 90% coverage.</li>
            <li>Use pytest fixtures to provide reusable resources (temporary directories, sample data).</li>
            <li>Mock a web API call using <code>responses</code> or <code>requests-mock</code> and test the client logic.</li>
            <li>Instrument a function with logging and use a test to assert logged messages (caplog in pytest).</li>
            <li>Reproduce a concurrency bug using threads and write tests that fail deterministically to aid debugging.</li>
            <li>Use <code>pdb.set_trace()</code> to step through a failing test and document the steps you took to find root cause.</li>
            <li>Demonstrate how adding type hints and using mypy can catch bugs early; add types to a module and run mypy.</li>
            <li>Set up a basic GitHub Actions workflow file that runs tests on push and on pull requests.</li>
            <li>Write a flaky test and then fix it by removing time-dependencies or seeding randomness.</li>
            <li>Use coverage.py to generate a coverage report and interpret uncovered lines to improve tests.</li>
            <li>Implement property-based tests for a function using hypothesis to discover edge cases.</li>
            <li>Write a post-mortem report for an intentionally broken script, listing cause, fix, and tests added to prevent recurrence.</li>
          </ol>
        </div>
      </div>
    </details>

    <footer style="margin-top:18px; font-size:0.95rem; color:#334e68;">
      <p>End of Chapter 20 notes. Practice more and get the heck of it.</p>
    </footer>
  </div>
</body>
</html>
